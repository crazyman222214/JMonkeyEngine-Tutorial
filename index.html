<!-- https://white-beach-02559cb1e.5.azurestaticapps.net -->


<!--TODO: Create code widgets to replace images of code-->
<!--TODO: Make Code tags link to their respective documentation-->
<!--TODO: Seperate the sections by having a "Closed/Open" logic through scrolling past a certain threshold-->
<!DOCTYPE html>
<head>
    <title>JMonkeyEngine</title>
    <link type="text/css" rel="stylesheet" href="./style/index.css" />
</head>
<html>
    <body>
        <header>
            <h1>JMonkeyEngine Tutorial</h1>
            <hr/>
        </header>
        <section id="TOCSection">
            <h2 id="TOC">Table of Contents:</h2>
            <hr/>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li>
                    <a href="#gettingStarted">Getting Started</a>
                    <ul>
                        <li><a href="#FirstRunningProject">First Running Project</a></li>
                        <li><a href="#OverridenMethods">Overriden Methods</a></li>
                    </ul>
                    <li><a href="#SimpleApplicationSection">Simple Application</a></li>
                    <ul>
                        <li><a href="#UnderstandingTheSimpleApplication">Understanding the <em>Simple</em> Application</a></li>
                        <li><a href="#Inilitialize">Inilitialize</a></li>
                    </ul>
                    <li><a href="#FlyByCameraSection">Fly By Camera</a></li>
                    <ul>
                        <li><a href="#UsingTheFlyByCamera">Using the Fly By Camera</a></li>
                        <li><a href="#HavingFunWithSimpleUpdate">Having Fun With simpleUpdate()</a></li>
                        
                    </ul>
                    <li><a href="#CreatingModelsSection">Creating Models</a></li>
                    <ul>
                        <li><a href="#AddingCustomAssets">Adding Custom Assets</a></li>
                        <li><a href="#AddingLighting">Adding Lighting</a></li>
                    </ul>
                </li>
            </ul>
        </section>
        <section id="introduction">
            <h2>Introduction</h2>
            <hr/>
            <p>
                JMonkeyEngine is a modern game engine written primarily written in Java. This is a very useful library with a very "code first" approach.
                In this tutorial, I will primarily be working within Intellij to showcase how this engine isn't tied to any SDK or IDE.
                However, the online documentation is rather sloppy for nieche problems or describing the functionality of a certain class.
            </p>
            <p>
                They have a <em>rather mediocre</em> sdk they have programmed with this game engine in mind with further documentation found within the inside code.
                That can be found <a href="https://github.com/jMonkeyEngine/sdk" target="_blank">here</a>. <br/> Otherwise, you can find more information about JMonkeyEngine and start a project <a href="https://jmonkeyengine.org" target="_blank">here</a>. 
                <img src="./images/GetStartedButton.png">
                Press this button on the website to start a project.
                Input the information for the project and press download a starter project. It is going to download a .zip file with a Java Project inside.
            </p>
            <p>
                This tutorial will not be a tutorial about anything specific, rather I will just demonstrate how to use the most critical parts of the engine.<br/>
                I will inevitably use assets from my 3d chess project, which were made in a 3d modeler such as Blender, but this <strong>will not</strong> be a tutorial for 3d modeling <em>yet</em>.
            </p>
        </section>
        <section id="gettingStarted">
            <h2 id="gettingStartedHead">Getting Started</h2>
            <hr />
            <h3 id="FirstRunningProject">First Running Project</h3>
            <p>
                Now that you have a starter project, you can open and run the project.
                The directory is
                <br/>-PROJECT_NAME-/src/main/java/-PACKAGE_NAME-/-PROJECT_NAME-
            </p>
            <img src="./images/FileDirectory.png" />
            <p>
                If you run the program just as it is, you should get a window that looks like this
            </p>
            <img src="./images/FirstRun.png">
            <p>
                That blue box is the one created by the initial <code>simpleInitApp()</code>
                The controls to use the camera are:
                <div class="container">
                    <ul>
                        <li>WASD to move</li>
                        <li> Q and Z to do up and down the Y-Axis</li>
                        <li>the mouse to look around</li>
                        <li>and ESC to close the program.</li>
                    </ul>
                </div>
            </p>
            <h3 id="OverridenMethods">Overriden Methods</h3>
            <p>
                Going back to the code, there are a few things of note.<br/>
                The <code>Main</code> method contains 3 lines of <strong>important</strong> code.
                <br/><code>Test app = new Test();</code> creates an instance of this class since <code>Main()</code> is static.
                <br><code>app.showSettings(false);</code> set this to true and see the settings.
                <br/><code>app.start();</code> starts the application.
            </p>
            <img src="./images/MainMethod.png" />
            <p>
                If you'll notice, there is also one other method with a body. The <code>simpleInitApp()</code> method is an overrided method from the parent class, <code>SimpleApplication</code>.
                It runs as soon as the app is ran inside the Main Method.
                <br/><code>Box b = new Box(1,1,1);</code> is creating a Box Shape, passing the dimensions through the constructor.
                <br/><code>Geometry geom = new Geometry("Box", b);</code> is creating a Geometry for the RootNode, passing through a String name of the shape and the variable we created previous, b.
                <br/><code>Material mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");</code> is defining the material, which is what the user actually sees, is defined using the <code>assetManager</code>, which is a variable inside our <code>SimpleApplication</code> and with the path of a unshaded texture.
                <br/><code>mat.setColor("Color", ColorRGBA.Blue);</code> is just setting the color of the material.
                <br/><code>geom.setMaterial(mat);</code> is setting the material of the geometry to the material we defined up above, <code>mat</code>.
                <br/><code>rootNode.attachChild(geom);</code> is attaching the geometry to the <code>rootNode</code>, a variable inside <code>SimpleApplication</code>
            </p>

            <img src="./images/SimpleInitApp.png" width="90%" />
            <p>The other two methods are part of the abstract methods, but will not be touched on right now.</p>
        </section>

        <section id="SimpleApplicationSection">
            <h2>SimpleApplication</h2>
            <hr/>
            <h3 id="UnderstandingTheSimpleApplication">Understanding the <em>Simple</em> Application</h3>
            <p>
                To truly learn how to operate the concrete class, it is important to delve into the abstract class to learn how what you can use from the parent.
                <br/> If you press Shift and click on SimpleApplication, it will bring you into the class. <br />
            </p>
            <img src="./images/SimpleApplication.png"/>
            <p>
                The first thing I would like to point out is at the bottom is the methods you inherit in your <code>Main</code> class.
            </p>
            <img src="./images/InheritedMethods.png" />

            <p>
                Another thing that would help in learning this library is to become familiar with what getters and setters are available to you. <br/>
                The next thing that I would like to point out is the constructor of the class. By default, it makes new instances of:
                <ul>
                    <li><code>StatsAppState</code></li>
                    <li><code>FlyCamAppState</code></li>
                    <li><code>AudioListenerState</code></li>
                    <li><code>DebugKeysAppState</code></li>
                    <li><code>ConstantVerifierState</code></li>
                </ul>
            </p>
            <p>
                This tutorial will be utilizing various methods/variables from these, but it isn't fully necessary to delve into the classes individually.<br />
                Just know they exist and when they get referenced in here, I will explain how it works.
            </p>
            <img src="./images/Constructor.png" />

            <h3 id="Inilitialize">Inilitialize</h3>
            <p>
                I am seperating this into it's own section purely because it is a big method and most of it is pretty important to understand as well. <br/>
            </p>
            <p>
                For the most part, this method is to create different variable and assign them. 
                <ol>
                    <li>The first notable part is assigning a <code>flyCam</code>, then assigns the state in the <code>stateManager</code>.</li>
                    <li>The next part adds the mapping to have ESC key close the program and F5 to Hide/Show the stats on the window.</li>
                    <li>After that, it calls the <code>simpleInitApp()</code>.</li>
                </ol>
            </p>
            <p>
                <strong>Meaning that as soon as the <code>Main</code> method is called, you need to have the first line make a new instance of the concrete class.</strong><br />
                As soon as the <code>Main</code> class runs, your <code>SimpleInitApp()</code> code will run <strong>before</strong> anything else in the <code>Main</code> method.<br/>
                This can be used to do things prior to when the user can see the pop-up window, but it also needs to be used precisely to avoid bugs.
            </p>
        </section>
        <section id="FlyByCameraSection">
            <h2 id="FlyByCamera">FlyByCamera</h2>
            <hr/>
            <h3 id="UsingTheFlyByCamera">Using the FlyByCamera</h3>
            <p>
                The <code>flyCam</code> variable is a public variable given to us through the parent class. This is the camera that the player can control.<br />
                To disable the camera, and disable the player being able to move it, you can use <code>flyCam.setEnabled(false);</code>
            </p>
            <img src="./images/setEnabled(false).png" />
            <p>
                While it may look the same, the user cannot interact with the camera.
            </p>
            <h3 id="MovingTheCamera">Moving The Camera</h3>
            <p>
                Because of how they have the encapsulation, we must interact with the position of the camera using <code>flyCam.onAnalog();</code><br/>
                This method takes in 3 parameters:
                <ol>
                    <li>String: Name</li>
                    <li>int: length</li>
                    <li>int: duration</li>
                </ol>
                <br/>
                The name parameter has a certain convention that they use. If you Shift + Click on the <code>onAnalog()</code> method, you can find the String Variables.<br />
                To find the string representation, you can Shift + Click on the CameraInput class to look at all of them.
            </p>
            <img src="./images/CameraInput.png"/>
            <p>
                Meaning that if I were to write the line <code>flyCam.onAnalog("FLYCAM_StrafeRight", 2, 200);</code> I would get something that looks like this:
            </p>
            <img src="./images/onAnalog(Right).png" />
            <h3 id="HavingFunWithSimpleUpdate">Having fun with simpleUpdate()</h3>
            <p>
                One of the defaulted methods within the <code>Main</code> class is the <code>simpleUpdate(float tpf)</code> method. <br/>
                The one parameter stands for Time Per Frame, which is the &Delta; (Delta) of time between each Frame. <br />
                We can utilize this part of the code to make it so that we move the camera every frame, effectively making an "Animation". <br />
            </p>
            <p>
                I would personally seperate the function call into a method, so that we can single out all camera movement into one method. <br />
                Also, I would recommend that you make the length of the camera movement <strong>WAY</strong> shorter so you can actually witness the animation.
            </p>
            <img src="./images/updateCamera.png" />

            <!--TODO: Make this a recording of JUST the tab so that the quality of the video isn't bad-->
            <video id="CameraAnimation" autoplay muted loop preload="auto">
                <source src="./images/CameraAnimation.mp4" type="video/mp4"/>
            </video>
        </section>
        <section id="CreatingModelsSection">
            <h2 id="Cre">Creating Models</h2>
            <hr>
            <h3 id="AddingCustomAssets">Adding Custom Assets</h3>
            <p>
                When I used this engine, It was to create a 3d chess game. So we needed to actually insert the assets into the engine.<br />
                To do this, we are going to need a .glb file type. In blender, you can export it to such a file.<br/>
                <strong>WARNING: This is not a tutorial on how to make a custom asset!</strong>
            </p>

            <p>
                Drag and drop the file into the file for assets. The directory for the file should be './resources/Models', just to keep conventions. <br />
                By default, JMonkeyEngine has an Empty file in every directory it creates in the resources folder. You can delete it to clean up the directory. <br />
            </p>
            <p>
                It should look something like this.
            </p>
            <img src="./images/ModelFileDirectory.png"/>
            <p>
                Now that we have the Model in the file directory, we can access the model and use it. <br>
                To access the file, we are going to use the assetManager & FileLocator import class from JMonkeyEngine. <br />
                This will help us to be able to access the files. <br />
            </p>
            <p>
                We need to call the <code>assetManager</code> class built into the <code>SimpleApplication</code> class and use the <code>.registerLocator("/Assets", FileLocator.Class)</code> method.<br />
                It has two parameters, the first string is to tell the <code>SimpleApplication</code> from which to locate assets for the given AssetLocator.<br />
                The second parameter is the class type of AssetLocator to use. Primarily you will just use the Parent <code>FileLocator</code> class, but there are use cases where subclasses can be useful!<br />
                Now we are going to use the <code>.loadModel(-File Directory-)</code>  method and store it as a <code>Spatial</code> variable.<br />
                Finally we can load the model using <code>rootNode.attachChild(object);</code>
            </p>
            <img src="./images/CreateAssetMethod.png" />
            <p>
                Now if you were to run the method, you would see something like this:
            </p>
            <img src="./images/BlankAssetWindow.png" />
            <h3 id="AddingLighting">Adding Lighting</h3>
            <p>
                As you can see, even though the asset is being created in the world, we cannot see it. <br />
                This is because loading assets use a lighting system to represent lighting <br />
                For this, we are going to use the <code>DirectionalLight</code> class. Just know that you can also use any subclass of the abstract <code>Light</code> class. <br />
                This class is rather simple to implement. First create an instance of the <code>DirectionalLight</code><br />
                Then we need to assign the direction of the light with <code>.setDirection(Vector3f)</code> method. <br />
                If you don't understand Vectors, just think of them as arrows pointing from a point outwards. <br />
                Since we are working in 3d, we need to give it an x, y, & z position <br />
                Normally we just declare a new instance of the <code>Vector3f</code> class anytime we need to use one. <br />
                So inside of the <code>setDirection()</code> method, we need to put <code>new Vector3f(-3, 5, 3).normalizelocal()</code> <br />
                Now I am not going to get into normalizing a vector, but it is just some math to make sure our vectors are correctly project our light. <br />
                Now all we need to do is add the light to the rootNode with <code>rootNode.addLight(dl)</code>
            </p>
            <img src="./images/OneDirectionalLight.png" />
            <p>
                If we were to run this, it will look like this:
            </p>
            <img src="./images/RunningOneDirectionalLight.png" />
            <p>
                Obviously this is not the intended outcome, but here comes the trouble of using DirectionalLight. <br />
                Since this is just shining light from a given point, it doesn't shine on all sides of the piece. <br />
                To fix this, we are going to use multiple DirectionalLight to project from all angles. <br />
                I have tried multiple variations of DirectionalLight placements, but for my project I found it best to have 3 DirectionalLights above the scene and 1 DirectionalLight below the scene. <br />
                This gets into the setup of your project, and how you want the shadows to appear. I encourage finding different positions to find the best lighting for your project. <br />
                My snippit of code like this:
            </p>
            <img  src="./images/FourDirectionalLight.png"/>
            <p>
                If you were to run it, it should look something like this:
            </p>
            <img src="./images/RunningFourDirectionalLight.png">
            <p>
                One reason I like DirectionalLight is that since you have 4 different light sources, you can use one of them to change the light properties. <br />
                I added this snippit of code to the simpleUpdate method so we can see a simple animation of the light source. <br />
                we can also change the color of the first DirectionalLight to red using the <code>.setColor(ColorRGBA.Red);</code> method so that we can actually see the animation. <br />
                The animation should look something like this:
            </p>
            <!--TODO: Record video for animation-->
            <p>
                Take a moment after the animation to look at how the colored light changes the asset. Now you can see the creativity of having DirectionalLight!<br />
                It may not be the right choice for your project, so I would encourage you also look into which subclass of <code>Light</code> to see which one suits your needs. <br />
                Test
            </p>
        </section>
        <!--TODO: Section for User Input-->
        <!--TODO: Section for Manipulating Game Objects-->
    </body>
</html>
<footer>
    &copy;2024 Christopher Schade
</footer>