<!-- https://white-beach-02559cb1e.5.azurestaticapps.net -->


<!--TODO: Create code widgets to replace images of code-->
<!--TODO: Make Code tags link to their respective documentation-->
<!--TODO: Seperate the sections by having a "Closed/Open" logic through scrolling past a certain threshold-->
<!DOCTYPE html>
<head>
    <title>JMonkeyEngine</title>
    <link type="text/css" rel="stylesheet" href="./style/index.css" />
</head>

<html>
    <body>
        <header>
            <h1>JMonkeyEngine Tutorial</h1>
        </header>
        <section id="TOCSection">
            <h2 id="TOC">Table of Contents:</h2>
            <hr/>
            <ul id="TOCList">
                <li><a href="#introduction">Introduction</a></li>
                <li>
                    <a href="#gettingStarted">Getting Started</a>
                    <ul>
                        <li><a href="#FirstRunningProject">First Running Project</a></li>
                        <li><a href="#OverridenMethods">Overriden Methods</a></li>
                    </ul>
                    <li><a href="#SimpleApplicationSection">Simple Application</a></li>
                    <ul>
                        <li><a href="#UnderstandingTheSimpleApplication">Understanding the <em>Simple</em> Application</a></li>
                        <li><a href="#Inilitialize">Inilitialize</a></li>
                    </ul>
                    <li><a href="#FlyByCameraSection">Fly By Camera</a></li>
                    <ul>
                        <li><a href="#UsingTheFlyByCamera">Using the Fly By Camera</a></li>
                        <li><a href="#HavingFunWithSimpleUpdate">Having Fun With simpleUpdate()</a></li>
                        
                    </ul>
                    <li><a href="#CreatingModelsSection">Creating Models</a></li>
                    <ul>
                        <li><a href="#AddingCustomAssets">Adding Custom Assets</a></li>
                        <li><a href="#AddingLighting">Adding Lighting</a></li>
                    </ul>
                </li>
            </ul>
        </section>
        <section id="introduction">
            <h2>Introduction</h2>
            <hr/>
            <p>
                JMonkeyEngine is a modern game engine written primarily written in Java. This is a very useful library with a "code first" approach.<br />
                However, the online documentation is rather sloppy for nieche problems or describing the functionality of a certain class.<br />
                In this tutorial, I will be working within Intellij to showcase how this engine isn't tied to any IDE.
            </p>
            <p>
                They have a <em>rather mediocre</em> sdk they have programmed with this game engine in mind with further documentation found within the inside code.
                That can be found <a href="https://github.com/jMonkeyEngine/sdk" target="_blank">here</a>. <br/> Otherwise, you can find more information about JMonkeyEngine and start a project <a href="https://jmonkeyengine.org" target="_blank">here</a>. 
                <img src="./images/GetStartedButton.png">
                Press this button on the website to start a project.
                Input the information for the project and press download a starter project. It is going to download a .zip file with a Java Project inside.
            </p>
            <p>
                This tutorial will not be a tutorial about anything specific, rather I will demonstrate how to use the most critical parts of the engine.<br/>
                I will inevitably use assets from my 3d chess project, which were made in a 3d modeler such as Blender, but this <strong>will not</strong> be a tutorial for 3d modeling.
            </p>
        </section>
        <section id="gettingStarted">
            <h2 id="gettingStartedHead">Getting Started</h2>
            <hr />
            <h3 id="FirstRunningProject">First Running Project</h3>
            <p>
                Now that you have a starter project, you can open and run the project. The directory is
                <br/>-PROJECT_NAME-/src/main/java/-PACKAGE_NAME-/-PROJECT_NAME-
            </p>
            <img src="./images/FileDirectory.png" />
            <p>
                If you run the program just as it is, you should get a window that looks like this:
            </p>
            <img src="./images/FirstRun.png">
            <p>
                That blue box is the one created by the initial <code>simpleInitApp()</code>
                The controls to use the camera are:
                <div class="container">
                    <ul>
                        <li>WASD to move</li>
                        <li> Q and Z to do up and down the Y-Axis</li>
                        <li>the mouse to look around</li>
                        <li>and ESC to close the program.</li>
                    </ul>
                </div>
            </p>
            <h3 id="OverridenMethods">Overriden Methods</h3>
            <p>
                Going back to the code, there are a few things of note.<br/>
                The <code>Main</code> method contains 3 lines of <strong>important</strong> code.
                <br/><code>Test app = new Test();</code> creates an instance of this class since <code>Main()</code> is static.
                <br><code>app.showSettings(false);</code> set this to true and see the settings.
                <br/><code>app.start();</code> starts the application.
            </p>

            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">public static void</div><div class="Name">Main()</div> <div>{</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Test</div> <div class="Name">app</div> <div>=</div> <div class="keyword">new</div> <div>Test();</div> </li>
                    <li><div class="Tab"></div><div class="Keyword">app</div><div class="Method">.setShowSettings(false);</div></li>
                    <li><div class="Tab"></div><div class="Keyword">app</div><div class="Method">.start();</div></li>
                    <li>}</li>
                </ol>
            </div>
            <p>
                If you'll notice, there is also one other method with a body. The <code>simpleInitApp()</code> method is an overrided method from the parent class, <code>SimpleApplication</code>.
                It runs as soon as the app is ran inside the Main Method.
                <br/><code>Box b = new Box(1,1,1);</code> is creating a Box Shape, passing the dimensions through the constructor.
                <br/><code>Geometry geom = new Geometry("Box", b);</code> is creating a Geometry for the RootNode, passing through a String name of the shape and the variable we created previous, b.
                <br/><code>Material mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");</code> is defining the material, which is what the user actually sees, is defined using the <code>assetManager</code>, which is a variable inside our <code>SimpleApplication</code> and with the path of a unshaded texture.
                <br/><code>mat.setColor("Color", ColorRGBA.Blue);</code> is just setting the color of the material.
                <br/><code>geom.setMaterial(mat);</code> is setting the material of the geometry to the material we defined up above, <code>mat</code>.
                <br/><code>rootNode.attachChild(geom);</code> is attaching the geometry to the <code>rootNode</code>, a variable inside <code>SimpleApplication</code>
            </p>

            <div class="CodeWidget">
                <ol>
                    <li><div class="Annotation">@Override</div></li>
                    <li><div class="Keyword">public void</div><div class="Name">SimpleInitApp()</div> <div>{</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Box</div><div class="Name">b</div><div>=</div><div class="keyword">new</div> <div>Box(1, 1, 1);</div> </li>
                    <li><div class="Tab"></div><div class="Keyword">Geometry</div> <div class="Name">geom</div> <div>=</div> <div class="keyword">new</div> <div>Geometry("Box", b);</div> </li>
                    <li></li>
                    <li><div class="Tab"></div><div class="Keyword">Material</div> <div class="Name">mat</div> <div>=</div> <div class="keyword">new</div> <div>Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");</div> </li>
                    <li><div class="Tab"></div><div class="Keyword">mat</div><div class="Method">.setColor("Color", ColorRGBA.Blue);</div></li>
                    <li><div class="Tab"></div><div class="Keyword">geom</div><div class="Method">.setMaterial(mat);</div></li>
                    <li></li>
                    <li><div class="Tab"></div><div class="Keyword">rootNode</div><div class="Method">.attachNode(mat);</div></li>
                    <li>}</li>
                </ol>
            </div>

            <p>The other two methods are part of the abstract methods, but will not be touched on right now.</p>
        </section>

        <section id="SimpleApplicationSection">
            <h2>SimpleApplication</h2>
            <hr/>
            <h3 id="UnderstandingTheSimpleApplication">Understanding the <em>Simple</em> Application</h3>
            <p>
                To truly learn how to operate the concrete class, it is important to delve into the abstract class to learn how what you can use from the parent.
                <br/> If you press Shift and click on SimpleApplication, it will bring you into the class. <br />
            </p>
            <img src="./images/SimpleApplication.png"/>
            <p>
                The first thing I would like to point out is at the bottom is the methods you inherit in your <code>Main</code> class.
            </p>
            <img src="./images/InheritedMethods.png" />

            <p>
                Another thing that would help in learning this library is to become familiar with what getters and setters are available to you. <br/>
                The next thing that I would like to point out is the constructor of the class. By default, it makes new instances of:
                <ul>
                    <li><code>StatsAppState</code></li>
                    <li><code>FlyCamAppState</code></li>
                    <li><code>AudioListenerState</code></li>
                    <li><code>DebugKeysAppState</code></li>
                    <li><code>ConstantVerifierState</code></li>
                </ul>
            </p>
            <p>
                This tutorial will be utilizing various variables from these, but it isn't fully necessary to delve into the classes individually.<br />
                Just know they exist and when they get referenced in here, I will explain how it works.
            </p>
            <img src="./images/Constructor.png" />

            <h3 id="Inilitialize">Inilitialize</h3>
            <p>
                I am seperating this into it's own section purely because it is a big method and most of it is pretty important to understand as well. <br/>
            </p>
            <p>
                For the most part, this method is to create different variable and assign them. 
                <ol>
                    <li>The first notable part is assigning a <code>flyCam</code>, then assigns the state in the <code>stateManager</code>.</li>
                    <li>The next part adds the mapping to have ESC key close the program and F5 to Hide/Show the stats on the window.</li>
                    <li>After that, it calls the <code>simpleInitApp()</code>.</li>
                </ol>
            </p>
            <p>
                <strong>Meaning that as soon as the <code>Main</code> method is called, you need to have the first line make a new instance of the concrete class.</strong><br />
                As soon as the <code>Main</code> class runs, your <code>SimpleInitApp()</code> code will run <strong>before</strong> anything else in the <code>Main</code> method.<br/>
                This can be used to do things prior to when the user can see the pop-up window, but it also needs to be used precisely to avoid bugs.
            </p>
        </section>
        <section id="FlyByCameraSection">
            <h2 id="FlyByCamera">FlyByCamera</h2>
            <hr/>
            <h3 id="UsingTheFlyByCamera">Using the FlyByCamera</h3>
            <p>
                The <code>flyCam</code> variable is a public variable given to us through the parent class. This is the camera that the player can control.<br />
                To disable the camera, and disable the player being able to move it, you can use <code>flyCam.setEnabled(false);</code>
            </p>

            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">flyCam</div><div class="Method">.setEnabled(false);</div></li>
                </ol>
            </div>

            <p>
                While it may look the same, the user cannot interact with the camera.
            </p>
            <h3 id="MovingTheCamera">Moving The Camera</h3>
            <p>
                Because of how they have the encapsulation, we must interact with the position of the camera using <code>flyCam.onAnalog();</code><br/>
                This method takes in 3 parameters:
                <ol>
                    <li>String: Name</li>
                    <li>int: length</li>
                    <li>int: duration</li>
                </ol>
                <br/>
                The name parameter has a certain convention that they use. <br/>
                If you Shift + Click on the <code>onAnalog()</code> method, you can find the String Variables.<br />
                To find the string representation, you can Shift + Click on the CameraInput class to look at all of them.
            </p>
            <img src="./images/CameraInput.png"/>
            <p>
                Meaning that if I were to write the line <code>flyCam.onAnalog("FLYCAM_StrafeRight", 2, 200);</code> I would get something that looks like this:
            </p>
            <img src="./images/onAnalog(Right).png" />
            <h3 id="HavingFunWithSimpleUpdate">Having fun with simpleUpdate()</h3>
            <p>
                One of the defaulted methods within the <code>Main</code> class is the <code>simpleUpdate(float tpf)</code> method. <br/>
                The one parameter stands for Time Per Frame, which is the &Delta; (Delta) of time between each Frame. <br />
                We can utilize this part of the code to make it so that we move the camera every frame, effectively making an "Animation". <br />
            </p>
            <p>
                I would personally seperate the function call into a method, so that we can single out all camera movement into one method. <br />
                Also, I would recommend that you make the length of the camera movement <strong>WAY</strong> shorter so you can actually witness the animation.
            </p>
            
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">private void</div><div class="Name">updateCamera()</div> <div>{</div></li>
                    <li><div class="Tab"></div><div class="Keyword">flyCam</div><div class="Method">.onAnalog("FLYCAM_StrafeRight", 0.02f, 300);</div></li>
                    <li>}</li>
                </ol>
            </div>

            <!--TODO: Make this a recording of JUST the tab so that the quality of the video isn't bad-->
            <video id="CameraAnimation" autoplay muted loop preload="auto">
                <source src="./images/CameraAnimation.mp4" type="video/mp4"/>
            </video>
        </section>
        <section id="CreatingModelsSection">
            <h2 id="Cre">Creating Models</h2>
            <hr>
            <h3 id="AddingCustomAssets">Adding Custom Assets</h3>
            <p>
                When I used this engine, It was to create a 3d chess game. So we needed to actually insert the assets into the engine.<br />
                To do this, we are going to need a .glb file type. In blender, you can export it to such a file.<br/>
                <strong>WARNING: This is not a tutorial on how to make a custom asset!</strong>
            </p>

            <p>
                Drag and drop the file into the file for assets. The directory for the file should be './resources/Models', just to keep conventions. <br />
                By default, JMonkeyEngine has an Empty file in every directory it creates in the resources folder. You can delete it to clean up the directory. <br />
            </p>
            <p>
                It should look something like this.
            </p>
            <img src="./images/ModelFileDirectory.png"/>
            <p>
                Now that we have the Model in the file directory, we can access the model and use it. <br>
                To access the file, we are going to use the assetManager & FileLocator import class from JMonkeyEngine. <br />
                This will help us to be able to access the files. <br />
            </p>
            <p>
                We need to call the <code>assetManager</code> class built into the <code>SimpleApplication</code> class and use the <code>.registerLocator("/Assets", FileLocator.Class)</code> method.<br />
                It has two parameters, the first string is to tell the <code>SimpleApplication</code> from which to locate assets for the given AssetLocator.<br />
                The second parameter is the class type of AssetLocator to use. Primarily you will just use the Parent <code>FileLocator</code> class, but there are use cases where subclasses can be useful!<br />
                Now we are going to use the <code>.loadModel(-File Directory-)</code>  method and store it as a <code>Spatial</code> variable.<br />
                Finally we can load the model using <code>rootNode.attachChild(object);</code>
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">private void</div><div class="Name">createAsset()</div> <div>{</div></li>
                    <li><div class="Tab"></div><div class="Keyword">assetManager</div><div class="Method">.registerLocator("/assets", FileLocator.class);</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Spatial</div><div class="Name">object</div> <div> = </div> <div class="Keyword">assetManager</div><div class="Method">.loadModel("Models/RookFileW.glb");</div></li>
                    <li><div class="Tab"></div><div class="Keyword">rootNode</div><div class="Method">.attachChild(object);</div></li>
                    <li>}</li>
        
                </ol>
            </div>
            <p>
                Now if you were to run the method, you would see something like this:
            </p>
            <img src="./images/BlankAssetWindow.png" />
            <h3 id="AddingLighting">Adding Lighting</h3>
            <p>
                As you can see, even though the asset is being created in the world, we cannot see it. <br />
                This is because loading assets use a lighting system to represent lighting <br />
                For this, we are going to use the <code>DirectionalLight</code> class. Just know that you can also use any subclass of the abstract <code>Light</code> class. <br />
                This class is rather simple to implement. First create an instance of the <code>DirectionalLight</code><br />
                Then we need to assign the direction of the light with <code>.setDirection(Vector3f)</code> method. <br />
                If you don't understand Vectors, just think of them as arrows pointing from a point outwards. <br />
                Since we are working in 3d, we need to give it an x, y, & z position <br />
                Normally we just declare a new instance of the <code>Vector3f</code> class anytime we need to use one. <br />
                So inside of the <code>setDirection()</code> method, we need to put <code>new Vector3f(-3, 5, 3).normalizelocal()</code> <br />
                Now I am not going to get into normalizing a vector, but it is just some math to make sure our vectors are correctly project our light. <br />
                Now all we need to do is add the light to the rootNode with <code>rootNode.addLight(dl)</code>
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">DirectionalLight</div><div class="Name">dl</div> <div> = </div><div class="Keyword">new</div> <div> DirectionalLight();</div></li>
                    <li><div class="Keyword">dl</div><div class="Method">.setDirection(</div><div class="Keyword">new</div><div>Vector3f(-3, 5, 3)</div><div class="Method">.normalizeLocal()</div><div>);</div></li>
                    <li><div class="Keyword">rootNode</div><div class="Method">.addLight(dl);</div></li>
                </ol>
            </div>
            <p>
                If we were to run this, it will look like this:
            </p>
            <img src="./images/RunningOneDirectionalLight.png" />
            <p>
                Obviously this is not the intended outcome, but here comes the trouble of using DirectionalLight. <br />
                Since this is just shining light from a given point, it doesn't shine on all sides of the piece. <br />
                To fix this, we are going to use multiple DirectionalLight to project from all angles. <br />
                I have tried multiple variations of DirectionalLight placements, but for my project I found it best to have 3 DirectionalLights above the scene and 1 DirectionalLight below the scene. <br />
                This gets into the setup of your project, and how you want the shadows to appear. I encourage finding different positions to find the best lighting for your project. <br />
                My snippit of code like this:
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">DirectionalLight</div><div class="Name">dl1</div> <div> = </div><div class="Keyword">new</div> <div> DirectionalLight();</div></li>
                    <li><div class="Keyword">dl1</div><div class="Method">.setDirection(</div><div class="Keyword">new</div><div>Vector3f(-3, 5, 3)</div><div class="Method">.normalizeLocal()</div><div>);</div></li>
                    <li><div class="Keyword">rootNode</div><div class="Method">.addLight(dl1);</div></li>
                    <li></li>
                    <li><div class="Keyword">DirectionalLight</div><div class="Name">dl2</div> <div> = </div><div class="Keyword">new</div> <div> DirectionalLight();</div></li>
                    <li><div class="Keyword">dl2</div><div class="Method">.setDirection(</div><div class="Keyword">new</div><div>Vector3f(-3, 5, 3)</div><div class="Method">.normalizeLocal()</div><div>);</div></li>
                    <li><div class="Keyword">rootNode</div><div class="Method">.addLight(dl2);</div></li>
                    <li></li>
                    <li><div class="Keyword">DirectionalLight</div><div class="Name">dl3</div> <div> = </div><div class="Keyword">new</div> <div> DirectionalLight();</div></li>
                    <li><div class="Keyword">dl3</div><div class="Method">.setDirection(</div><div class="Keyword">new</div><div>Vector3f(-3, 5, 3)</div><div class="Method">.normalizeLocal()</div><div>);</div></li>
                    <li><div class="Keyword">rootNode</div><div class="Method">.addLight(dl3);</div></li>
                    <li></li>
                    <li><div class="Keyword">DirectionalLight</div><div class="Name">dl4</div> <div> = </div><div class="Keyword">new</div> <div> DirectionalLight();</div></li>
                    <li><div class="Keyword">dl4</div><div class="Method">.setDirection(</div><div class="Keyword">new</div><div>Vector3f(-3, 5, 3)</div><div class="Method">.normalizeLocal()</div><div>);</div></li>
                    <li><div class="Keyword">rootNode</div><div class="Method">.addLight(dl4);</div></li>
                    <li></li>
                </ol>
            </div>
            <p>
                If you were to run it, it should look something like this:
            </p>
            <img src="./images/RunningFourDirectionalLight.png">
            <p>
                One reason I like DirectionalLight is that since you have 4 different light sources, you can use one of them to change the light properties. <br />
                I added this snippit of code to the simpleUpdate method so we can see a simple animation of the light source. <br />
                we can also change the color of the first DirectionalLight to red using the <code>.setColor(ColorRGBA.Red);</code> method so that we can actually see the animation. <br />
                The animation should look something like this:
            </p>
            <!--TODO: Record video for animation-->
            <p>
                Take a moment after the animation to look at how the colored light changes the asset. Now you can see the creativity of having DirectionalLight!<br />
                It may not be the right choice for your project, so I would encourage you also look into which subclass of <code>Light</code> to see which one suits your needs. <br />
            </p>
        </section>
        <section id="UserInputSection">
            <h2 id="UserInput">User Input</h2>
            <h3 id="KeyboardInput">Keyboard Input</h3>
            <p>
                To implement user input in the form of keyboard input, we need to implement the <code>ActionListener</code> interface. <br />
                If we look inside this interface, we see that we only need to override the <code>onAction()</code> method, that has 3 parameters. <br />
                <ol>
                    <li>String name: The name of the input we are going to use</li>
                    <li>bool isPressed: Tells if the input was pressed or not</li>
                    <li>float tpf: the time inbetween each frame</li>
                </ol>
            </p>
            <p>
                The way we implement this is two fold:
                <ol>
                    <li>Make the Methods for each input we want</li>
                    <li>Tell the <code>inputManager</code> what mappings to listen for and which listener is handling the events</li>
                </ol>
            </p>
            <p>
                First let's tackle the methods for the inputs we want. <br />
                I am going to make a small method for demonstrational purposes, but for each project will come different inputs needed. <br />
                One Example is if you need to lock the camera into a certain position in the world <br />
                We can use the parameters to our advantage as we can make sure that the button is pressed and that it is the certain input. <br />
                Since the inputs are a string field that you input, they could be named anything but it is common to use something that is relevant to the input. <br />
                For this I am just using "P" since I am creating an event that uses the P key. <br />
                If these conditions are true, we are going to enable the camera just in case it got disabled and move it 5 units to the left. <br />
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">final private</div><div class="Name">actionListener</div> <div>=</div> <div class="Keyword">new </div><div>ActionListener(){</div></li>
                    <li><div class="Tab"></div><div class="Annotation">@Override</div></li>
                    <li><div class="Tab"></div><div class="Keyword">public void</div> <div class="Name">onAction</div><div>(String name, boolean isPressed, float fps) {</div></li>
                    <li><div class="Tab"></div><div class="Tab"></div><div class="Keyword">if</div> <div>(isPressed) {</div></li>
                    <li><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div><div class="Keyword">if</div><div> (name == "P") {</div></li>
                    <li><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div><div class="Keyword">flyCam</div><div class="Method">.SetEnabled(false);</div></li>
                    <li><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div><div class="Keyword">flyCam</div><div class="Method">.onAnalog("FLYCAM_StrafeLeft",  5f, 300);</div></li>
                    <li><div class="Tab"></div><div class="Tab"></div><div class="Tab"></div>}</li>
                    <li><div class="Tab"></div><div class="Tab"></div>}</li>
                    <li><div class="Tab"></div>}</li>
                    <li>}</li>
                </ol>
            </div>
            <p>
                Obviously this is simplistic, but we can implement more complex methods later. <br />
                We now need to tell the <code>inputManager</code> about our inputs. <br />
                We can do this by using the <code>.addMapping()</code> & <code>.addListener</code> methods. <br />
                We have a couple parameters with the <code>.addMapping()</code> method. <br />
                We need the String mapping name, which for this is "P", <br />
                We also need a <code>KeyTrigger</code> object, which takes a enum value, or technically an int value. <br />
                We can use the <code>KeyInput</code> enum to acomplish this. <br />
            </p>
            <p>
                After we map the input to the inputManager, then we need to add reference to the ActionListener that is going to listen and respond for the action.<br />
                This also takes two parameters <br />
                The first one is the ActionListener object, and the other one is the name of our mapping.<br />
                I seperated this into a method since we are going to expand on different types of user input<br />
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">private void</div><div class="Name">addTriggers</div> <div>() {</div></li>
                    <li><div class="Tab"></div><div class="Keyword">inputManager</div><div class="Method">.addMapping("P", </div><div class="Keyword">new</div><div> Keytrigger(KeyInput.KEY_P));</div></li>
                    <li><div class="Tab"></div><div class="Keyword">inputManager</div><div class="Method">.addListener(actionListener, "P");</div></li>
                    
                    <li>}</li>
                </ol>
            </div>
            <img src="./images/addTriggersMethod.png" />
            <h3 id="MouseInput">Mouse Input</h3>
            <p>
                <strong>This section is going to be a precursor to the next section, so you need to read this before the next section.</strong><br /><br />

                This concept in itself is pretty simple since JMonkeyEngine handles a lot of the math, but understanding the math at a fundamental level is needed to understand the code. <br />
                So, to get mouse input is another input managed by the ActionListener, so we can quickly implement that for the left click. <br />
                When we add the mapping, we need to use a <code>MouseButtonTrigger</code> object and use the <code>MouseInput.BUTTON_LEFT</code> enum value for the constructor. <br />
                Other than that, it is the same process as before. In the if statement inside the <code>actionListener</code>, I am calling a method I will be doing the logic in. <br />
            </p>
            <p>
                So we are going to do a simple method that detects if you are clicking an object in the world.<br />
                To do this, we need to create a <code>CollisionResults</code> variable, which is going to hold the result of our collision.<br />
                We also need to get the cursor position on the screen, which is stored as a Vector2f. <br />
                We can get this through the <code>inputManager.getCursorPosition()</code> method. <br />
                Although the screen is 2d, we need to interact with the world, we need three dimensions. <br/>
                We can get this through the <code>cam.getWorldCoordinates()</code> method.
                The two parameters are our Vector2f, and the Z position you want to project at. For this I am going to leave it at 0. <br /><br />

                We also need to get the direction that the cursor is pointing in reference to the 3d world. <br />
                To do this, we are going to use the <code>cam.getWorldCoordinates()</code> <br />
                We are still going to use our cursor position, but for the Z position, we are going to put 1. <br />
                After we get the coordinate, we need to subtract it from our position in 3d to get a vector that represents the direction of our point in reference to our world. <br />
                We still need to normalize the vector. <br />
            </p>

            <p>
                Now that we have the point in space that we are clicking at and a direction that we are clicking towards, we can now create a <code>Ray</code>. <br />
                This ray is a mathematical ray, that starts at a point and is a one-directional line going into a direction. <br />
                Using this, we can check for collisions with the <code>rootNode.collideWith()</code> method. <br />
                The two parameters it wants is our ray that we just created, and the <code>CollisionResults</code> variable we made at the beginning. <br />
                This method finds the collision of all objects that collides with the ray and compiles it into our <code>CollisionResults</code> for us to use. <br />
                If you look inside the <code>CollisionResults</code> class, you can see that it has an arraylist of <code>CollisionResult</code>, <br />
                That class has the Geometry that we collided with, the contact point, and distance, along with a few others but we aren't interested in them. <br />
                With this, we can index into the Geometry that we have clicked. <br />
                Using <code>results.getCollision(0).getGeometry()</code>, we have access to the geometry and can manipulate it.
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Keyword">private void</div><div class="Name">clickMouse</div> <div>() {</div></li>
                    <li><div class="Tab"></div><div class="Keyword">CollisionResults</div><div class="Name">results</div><div> = </div><div class="Keyword">new</div><div>CollisionResults();</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Vector2f</div><div class="Name">cursorPosition</div><div> = </div><div class="Keyword">inputManager</div><div class="Method">.getCursorPosition();</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Vector3f</div><div class="Name">click3d</div><div> = </div><div class="Keyword">cam</div><div class="Method">.getWorldCoordinates(cursorPosition, 0f);</div></li>
                    <li><div class="Tab"></div><div class="Keyword">Vector3f</div><div class="Name">direction</div><div> = </div><div class="Keyword">cam</div><div class="Method">.getWorldCoordinates(cursorPosition, 1f).subtractLocal(click3d).normalizeLocal();</div></li>
                    <li></li>
                    <li><div class="Tab"></div><div class="Keyword">Ray</div><div class="Name">ray</div><div> = </div><div class="Keyword">new</div><div>Ray(click3d, direction);</div></li>
                    <li><div class="Tab"></div><div class="Keyword">rootNode</div><div class="Method">.collideWith(ray, results);</div></li>
                    <li></li>
                    <li><div class="Tab"></div><div class="Keyword">Geometry</div><div class="Name">geometry</div><div> = </div><div class="Keyword">results</div><div class="Method">.getCollision(0).getGeometry();</div></li>
                    <li><div class="Tab"></div><div class=Keyword>System</div><div class="Method">.Out.Println(geometry.getName());</div></li>
                    <li>}</li>
                </ol>
            </div>
        </section>
        <section id="ManipulatingGameObjectsSection">
            <h2 id="ManipulatingGamObjects">Manipulating Game Objects</h2>
            <h3>Understanding World & Local Transforms</h3>
            <p><strong>WARNING: This section builds on the last section, so read that section before moving on</strong></p>
            <p>
                To properly understand how to manipulate game objects, first you need to know the difference between Local transformations & World transformations. <br />
                <ul>
                    <li>World transformations are in relation to the entire world,</li>
                    <li>And Local transformations are in relation to just the object and it's transformations</li>
                </ul>
            </p>
            <p>
                The difference will become apparent once you use them. They both have their reasons to be used.<br/>
                From the last section, we now have access to the geometry in our world, so we can use that to see the difference<br />
                If you type <code>geometry.</code>, you can see all of the methods available to you. <br/>
                Notice that you can set local translation, but you cannot set world translation<br/>
                This is because the world translation is the position relative to the world, so it doesn't make sense for the geometry to set the world's translation<br />
                Although you cannot set the world translation, you can get the world translation, and this is so that you can know where the geometry is in relation to the world<br />
                If we were to set local translation, we are setting how many units away from the spawn location of the geometry. <br />
                This is a important part to understand as where the geometry spawn is regarded as (0,0,0) with local translation<br />
                There is another method that works similarly, and that is the <code>.move()</code> method. <br />
                The <code>.move()</code> method moves the geometry from it's given position. <br />
                This is the equivalent to a += operator, as it takes the current position and moves it in the given Vector3f <br/>
                For the most part, it is more intuitive to use <code>.move()</code> over <code>.setLocalTranslation()</code>, with the exception of moving the geometry for the first time since the geometry is at (0,0,0) <br/>
            </p>
            <div class="CodeWidget">
                <ol>
                    <li><div class="Comment">//Sets the local translation to (3,3,3)</div></li>
                    <li><div class="Keyword">geometry</div><div class="Method">.setLocalTranslation(</div><div class="Keyword">new</div><div>Vector3f(3,3,3));</div></li>
                    <li></li>
                    <li><div class="Comment">//From the local translation (3,3,3), it will move it another 3 units</div></li>
                    <li><div class="Comment">//Making the local translation (6,6,6)</div></li>
                    <li><div class="Keyword">geometry</div><div class="Method">.move(</div><div class="Keyword">new</div><div>Vector3f(3,3,3));</div></li>
                    <li></li>
                    <li><div class="Comment">//Returns the translation of geometry in relation to world coordinates</div></li>
                    <li><div class="Keyword">geometry</div><div class="Method">.getWordTranslation();</div></li>
                </ol>
            </div>
        </section>

        <section id="FinalThoughtsSection">
            <h2>Final Thoughts</h2>
            <p>
                I want to finish the off with a few thoughts and ideas to further progress your project.<br />
                First thing is to remember that this is a game engine, and uses a lot of common concpets within game engines.<br />
                JMonkeyEngine is basic in the sense that it is code-based, and doesn't have an interface like commercial game engines.<br />
                That being said, everything that you learn within JMonkeyEngine can be transfered to other game engines, and vice versa.<br/>
            </p>
            <p>
                Another thing I want to point out is that there is great power in determination.<br />
                If you have read through this tutorial, that probably means that you are planning a project and have an idea in mind.<br />
                I have given a lot of fundamentals, but there is a lot of functionality in this SDK that I haven't explained.<br />
                Making an entire game without an interface can be challenging at times, so debugging will become your best friend.<br/>
                Don't let the idea of debugging discourage you; instead use it to understand what your code is doing.<br />
                Creating a game to perfection takes a lot of work, but as long as you keep moving forward and continue learning, anything is possible!<br /> 
            </p>
        </section>

    </body>
</html>
<footer>
    <div id="FooterContainer"><div>&copy;2024 Christopher Schade</div></div>
</footer>